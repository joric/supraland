<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" type="image/x-icon" href="data:image/x-icon;," />
<title>Joric's Supraland 3D</title>
<style type="text/css">
html,body{margin:0px;height:100%;width:100%; font-family:sans-serif;}
.container{width:100%;height:100%}
</style>

<!-- maptalks -->
<link rel="stylesheet" href="https://unpkg.com/maptalks/dist/maptalks.css">
<script type="text/javascript" src="https://unpkg.com/maptalks/dist/maptalks.min.js"></script>

<script type="text/javascript" src="simplify.js"></script>

<!-- font awesome  -->
<!--link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" /-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/all.min.js" integrity="sha512-u3fPA7V8qQmhBPNT5quvaXVa1mnnLSXUep5PS1qo5NRzHwG19aHmNJnj1Q8hpA/nBWZtZD4r4AX6YOt5ynLN2g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<base href="../"></base>
<body>
<div id="map" class="container"></div>
<script>

let heightFactor = 0.5;
let startPitch = 45;
let defaultZoom = 4;
let defaultPitch = 45;
let defaultBearing = 0;
let enableAltitude = true;
let drawAltitude = true;
let drawShadow = false;
let markerSymbol = markerSymbol3;
let symbolCache = {};
let map = null;

let markerColors = ['#48a1c2','#f4bd76','#419869','#88cf78','#988','#877','#766','#e4e1d6'];
let lineColor = '#888';
let colors = {};
let items = {
  'Chest_C':'chest',
  'BP_EngagementCup_Base_C':'trophy',
  'Bones_C':'bones',
  'PipesystemNew_C':'pipe_green',
  'PipesystemNewDLC_C':'pipe_green',
  'Scrap_C':'scrap',
  //'EnemySpawn1_C':'grave_wood', 'EnemySpawn2_C':'grave_stone', 'EnemySpawn3_C':'grave_volcano',
  //'Coin_C':'coin',
  'Jumppad_C':'map',
  //'_JumppadTarget_C':'question_mark',
  'BarrelRed_C':'barrel_red',
  'BarrelColor_C': 'barrel_gold',
  'BarrelClosed_Blueprint_C': 'barrel_gold',
};

let icons = {
  'jumppad_blue':  {icon: 'circle-chevron-up',   color: 'dodgerblue'},
  'jumppad_red':   {icon: 'circle-chevron-up',   color: 'red'},
  'chest':         {icon: 'toolbox',             color: 'grey'},
  'trophy':        {icon: 'trophy',              color: 'peru'},
  'bones':         {icon: 'skull-crossbones',    color: 'goldenrod'},
  'pipe_green':    {icon: 'circle-chevron-down', color: 'yellowgreen'},
  'grave_wood':    {icon: 'cross',               color: 'sienna'},
  'grave_stone':   {icon: 'cross',               color: 'dimgrey'},
  'grave_volcano': {icon: 'cross',               color: 'tomato'},
  'coin':          {icon: 'coins',               color: 'orange'},
  'scrap':         {icon: 'gear',                color: 'darkcyan'},
  'barrel_red':    {icon: 'prescription-bottle', color: 'maroon'},
  'barrel_gold':   {icon: 'prescription-bottle', color: 'chocolate'},
};

let bindings = {
  KeyA:['x',+1],KeyD:['x',-1],
  KeyW:['y',+1],KeyS:['y',-1],
  KeyQ:['b',+1],KeyE:['b',-1],
  KeyT:['z',+1],KeyG:['z',-1],
  KeyX:['p',+1],KeyZ:['p',-1],
};

let maps = {
  // data taken from the MapWorld* nodes
  'sl':  { 
      title: 'Supraland',
      "MapWorldCenter": { "X": 13000.0, "Y": -2000.0, "Z": 0.0 },
      "MapWorldSize": 175000.0,
      "MapWorldUpperLeft": { "X": -74500.0, "Y": -89500.0, "Z": 0.0 },
      "MapWorldLowerRight": { "X": 100500.0, "Y": 85500.0, "Z": 0.0 },
  },

  'slc': {
    title: 'Supraland Crash',
      "MapWorldCenter": { "X": 25991.0, "Y": -16.0, "Z": 0.0  },
      "MapWorldSize": 90112.0,
      "MapWorldUpperLeft": { "X": -19065.0, "Y": -45040.0, "Z": 0.0 },
      "MapWorldLowerRight": { "X": 71047.0, "Y": 45072.0, "Z": 0.0 },
  },

  'siu': {
      title: 'Supraland Six Inches Under',
      "MapWorldCenter": { "X": 0.0, "Y": -19000.0, "Z": 10000.0 },
      "MapWorldSize": 147456.0,
      "MapWorldUpperLeft": { "X": -73728.0, "Y": -92728.0, "Z": 10000.0 },
      "MapWorldLowerRight": { "X": 73728.0, "Y": 54728.0, "Z": 10000.0 },
  },
};

function markerSymbol1(icon, shadow=false) {
  if (shadow) {
    return [
      {
        markerWidth: 32,
        markerHeight: 32,
        markerFill: '#000',
        markerType: 'ellipse',
      }
    ];
  }
  return [
    {
      markerFile: 'img/'+icon+'.png',
      markerWidth  : 32,
      markerHeight : 32,
      markerDy: 16,
    },
  ];
}

function markerSymbol2(icon, shadow=false) {
  if (shadow) {
    return [
      {
        markerWidth: 75,
        markerHeight: 75,
        markerFill: '#000',
        markerType: 'pin',
      },
    ];
  }
  return [
    {
      markerWidth: 75,
      markerHeight: 75,
      markerFill: colors[icon],
      markerType: 'pin',
    },
    {
      markerFile: 'img/'+icon+'.png',
      markerWidth  : 32,
      markerHeight : 32,
      markerDy: -22,
    },
  ];
}

function markerSymbol3(icon, shadow=false) {
  let d = 48;
  let iconName = icons[icon].icon;
  let color = icons[icon].color;
  let [w1,h1,[s1],c1,p1] = FontAwesome.icon({ iconName: 'location-pin' }).icon;

  if (!(t = FontAwesome.icon({ iconName: iconName }))) {
    t = FontAwesome.icon({ iconName: 'question' });
  }

  let [w2,h2,[s2],c2,p2] = t.icon;

  let dx = 64 + (512-w2)/4;
  let dy = 64 + (512-h2)/4;
  let path = [
    {path:p1, fill: 'black'},
    {transform: 'matrix(0.976,0,0,0.976,5,5)', path: p1, fill: color},
    {transform: 'matrix(0.5,0,0,0.5,'+dx+','+dy+')', path:p2, fill: 'white'}
  ];
  return {
    markerType: 'path',
    markerPath : path,
    markerPathWidth : w1,
    markerPathHeight : h1,
    markerLineColor : 12,
    markerWidth: w1*d/512,
    markerHeight: h1*d/512,
    markerDy : 0,
    markerDx : 0
  };
}

function loadMap(mapId) {
  location.hash = mapId;

  document.querySelector('#map').style.backgroundColor = mapId=='siu' ? '#141414' : '#000';

  if (map) {
    map.remove();
  }

  let p = maps[mapId];
  let mapSize = {width: 8192, height: 8192}
  let scale = p.MapWorldSize / mapSize.width;
  let [left,top,right,bottom] = [p.MapWorldUpperLeft.X, p.MapWorldUpperLeft.Y, p.MapWorldLowerRight.X, p.MapWorldLowerRight.Y];
  let extent = new maptalks.Extent(left, top, right, bottom);
  center = [p.MapWorldCenter.X, p.MapWorldCenter.Y];

  map = new maptalks.Map('map', {
    zoom: defaultZoom,
    pitch: startPitch,
    bearing: defaultBearing,
    heightFactor: heightFactor,
    center: center,
    maxExtent: extent,
    maxPitch: 80,
    spatialReference : {
      projection : 'identity',
      resolutions: [32,16,8,4,2,1,1/2,1/4,1/8].map(x=>x*scale),
      fullExtent : { top: top, left: left, bottom: bottom, right: right },
    },
    baseLayer: new maptalks.TileLayer('base', {
      maxAvailableZoom: 4,
      urlTemplate: 'tiles/'+mapId+'/base/{z}/{x}/{y}.jpg',
      repeatWorld: false,
      tileSystem: [ 1, -1, left, top ],
      attribution: '<a href="https://github.com/joric/supraland" target="_blank">Joric\'s Supraland</a>',
    }),
    seamlessZoom: true,
    doubleClickZoom: true,
    zoomControl: {
      //position  : 'bottom-right',
      position  : 'top-right',
      zoomLevel : false,
    },
    compassControl: {
      //position: {right:20, bottom: 90},
      position  : 'bottom-right',
    },
  });

  let shadowLayer = new maptalks.VectorLayer('shadow', {
    enableAltitude: enableAltitude,
    sortByDistanceToCamera: true,
    opacity: 0.25,
  }).addTo(map);

  let lineLayer = new maptalks.VectorLayer('lines', {
    enableAltitude: enableAltitude,
    sortByDistanceToCamera: true,
  }).addTo(map);

  let vectorLayer = new maptalks.VectorLayer('vector', {
    enableAltitude: enableAltitude,
    sortByDistanceToCamera: true,
  }).addTo(map);

  if (drawAltitude) {
    vectorLayer.setOptions({drawAltitude : {lineWidth : 2, lineColor : '#888'}});
    //lineLayer.setOptions({drawAltitude : {lineWidth : 1, lineColor : '#888'}});
  }

  for (const fname of ['markers','custom-markers'])
    fetch('data/'+fname+'.'+mapId+'.json')
    .then((response) => response.json())
    .then((j) => {

      let objects = {};

      for (const o of j) {

        if (! (o.lng>left && o.lng<right && o.lat>top && o.lat<bottom )) {
          continue;
        }

        if (icon = items[o.type]) {

          if (o.type == 'Jumppad_C') {// && o.name=='Jumppad2_49') {

            if (r = o.direction) {
              let x1 = o.lng;
              let y1 = o.lat;
              let z1 = o.alt;

              let k = o.relative_velocity || 1000;

              let vx = -o.direction.x * k;
              let vy = -o.direction.y * k;
              let vz = o.direction.z * k;

              if (o.velocity && o.allow_stomp) {
                vx = o.velocity.x;
                vy = o.velocity.y;
                vz = o.velocity.z;
              }

              icon = (o.allow_stomp || o.disable_movement==false) ? 'jumppad_blue' : 'jumppad_red';

              let x = x0 = o.lng;
              let y = y0 = o.lat;
              let z = z0 = o.alt;

              let dt = 0.01;
              let g = 9.8;
              let m = 95;

              let last_z = z;
              let points = []
              points.push({x:x,y:y,z:z})

              for (let t=0;t<20;t+=dt) {
                vz -= g * m * dt;
                x += vx * dt;
                y += vy * dt;
                z += vz * dt;

                points.push({x:x,y:y,z:z})

                if (last_z>z) {
                  if (o.target) {
                    if (o.target.z>z) break;
                  } else {
                    if (o.alt>0 && z<0) break;
                    if (o.alt<0 && z<o.alt) break;
                  }
                }
                last_z = z;
              }

              let color = icons[icon].color;

              //console.log('before',points.length);
              points = simplify(points, 10);
              //console.log('after',points.length);

              if (points.length>1) {
                new maptalks.LineString(points,{symbol:{lineColor: color, lineWidth: 2}}).addTo(lineLayer);
              }
            }
          } // end of jumppad

          if (!symbolCache.hasOwnProperty(icon)) {
            symbolCache[icon] = markerSymbol(icon);
          }

          var marker = new maptalks.Marker([o.lng, o.lat, o.alt],{
            properties: {name: o.name},
            symbol: symbolCache[icon],
          }).addTo(vectorLayer);

          new maptalks.ui.ToolTip(o.name,{}).addTo(marker);

          marker.setInfoWindow({
            title     : o.name,
            content   : JSON.stringify(o, null, 2).replaceAll('\n','<br>').replaceAll(' ','&nbsp;'),
            autoPan: true,
            autoCloseOn : 'click',
            dy: 22,
          });

          if (drawShadow) {
            new maptalks.Marker([o.lng, o.lat],{
              cursor: 'arrow',
              symbol: markerSymbol(o.icon, true),
            })
            .addTo(shadowLayer);
          }
        }
        objects[o.area + ':' + o.name] = o;
      }

      for (name of Object.keys(objects)) {
        let o = objects[name];
        if (o.other_pipe) {
          let icon = items[o.type];
          let color = icons[icon].color;
          if (p = objects[o.other_pipe]) {
            let points = [[o.lng, o.lat, o.alt],[p.lng, p.lat, p.alt]];
            //new maptalks.LineString(points,{symbol:{lineColor: color, lineWidth: 2, lineDasharray:[10,5,5]}}).addTo(lineLayer);
            new maptalks.LineString(points,{symbol:{lineColor: color, lineWidth: 2,}}).addTo(lineLayer);
          }
        }
      }
   });

  var toolbar = new maptalks.control.Toolbar({
    'position' : 'top-left',
    items: [
      { item : 'sl', click : function() { loadMap('sl'); }},
      { item : 'slc', click : function() { loadMap('slc'); }},
      { item : 'siu', click : function() { loadMap('siu'); }},
    ]
  }).addTo(map);

  function copyToClipboard(s) {
    let c = document.body.appendChild(document.createElement("input"));
    c.value = s;
    c.focus();
    c.select();
    document.execCommand('copy');
    c.parentNode.removeChild(c);
    console.log('copied to clipboard:', s);
  }

  // context menu
  var options = {
    'items'  : [
      {
        item: 'Copy Map View URL',
        click: function () {
          let base = window.location.href.replace(/#.*$/,'');
          let v = map.getView();
          let p = {m:mapId, z:v.zoom, c:v.center, p:v.pitch, b:v.bearing};
          let url = base +'#' + Object.entries(p).map(e=>e.join('=')).join('&');
          copyToClipboard(url);
        }
      },
      //'-',{item: 'item2', click: function () { alert('Click item2'); }}
    ]
  };
  map.setMenu(options);

  document.querySelector('.maptalks-compass').title = 'Click to reset (key R)';
  document.querySelector('.maptalks-compass').onclick = function(e) {
    if (map.getBearing()==0) {
      map.animateTo({ pitch: map.getPitch()==0 ? defaultPitch : 0 });
    }
  };

  //window.addEventListener('contextmenu', function(e) { e.stopPropagation()}, true); // enable default context menu

  [].forEach.call(document.querySelectorAll('.maptalks-toolbar-hx > li'), function(div) {
    if (div.innerText==mapId) {
      div.style.background = '#6a97d9';
      div.style.color = '#fff';
    }
  });
}

function resetPitch(e) {
  if (map.isAnimating()) return;
  if (map.getBearing()!=0) {
    map.animateTo({ bearing: 0 });
  } else {
    map.animateTo({ pitch: map.getPitch()==0 ? defaultPitch : 0 });
  }
}

window.onload = function(event) {
  mapId = Object.keys(maps).find(id=>location.hash.endsWith(id)) || 'sl';

  const ctx = document.createElement('canvas').getContext('2d',{ willReadFrequently: true });
  function getDominantColor(imageObject, amp) {
    ctx.drawImage(imageObject, 0, 0, 1, 1);
    const c = ctx.getImageData(0, 0, 1, 1).data;
    for (let i=0; i<3; i++) c[i] = Math.round(Math.min(255,c[i]*amp));
    return "#"+((1<<24)+(c[0]<<16)+(c[1]<<8)+c[2]).toString(16).slice(1);
  }

  // preload all colors and load map
  for (key of Object.keys(items)) {
    const image = new Image();
    image.param = items[key];
    image.onload = function(e) {
      ctx.drawImage(image,0,0,100,100);
      colors[image.param] = getDominantColor(image, 1.25);
      if (Object.keys(items).length >= Object.keys(colors).length) {
        loadMap(mapId);
      }
    };
    image.onerror = function() {
      colors[image.param] = '#888';
      if (Object.keys(items).length >= Object.keys(colors).length) {
        loadMap(mapId);
      }
    };
    image.src = 'img/'+items[key]+'.png';
  }

  let pressed = {};

  function update(timestep) {
    let step = 25;
    let v = {};
    for (key of Object.keys(bindings)) {
      if (pressed[key]) {
        let [dir, step] = bindings[key];
        v[dir] = (v[dir]||0) + step;
      }
    }
    (v.x || v.y) && map.panBy([(v.x||0)*step, (v.y||0)*step], {duration: 1});
    v.b && map.setBearing(map.getBearing()+v.b*step/10);
    v.p && map.setPitch(map.getPitch()+v.p*step/10, {duration: 1});
    v.z && map.setZoom(map.getZoom()+v.z/16, {duration: 1});
    window.requestAnimationFrame(update);
  }

  window.addEventListener('keyup', (e) => {
    delete pressed[e.code];
  });

  window.addEventListener("keydown",function (e) {
    //console.log(e.code);
    pressed[e.code] = true;
    switch (e.code) {
      case 'KeyF':
        if (e.ctrlKey) {
          //e.preventDefault();
        } else if (!e.target.id.startsWith('searchtext')) {
          //map.toggleFullscreen();
        }
        break;
      case 'KeyR': resetPitch(); break;
      case 'KeyG': map.panTo(center); break;
      case 'Digit1': loadMap('sl'); break;
      case 'Digit2': loadMap('slc'); break;
      case 'Digit3': loadMap('siu'); break;
    }
  });

  window.requestAnimationFrame(update);

  // redraw (need font awesome)
  //setTimeout(function(){map.setPitch(map.getPitch()+0.01);},1000);
}
</script>
</body>
</html>

